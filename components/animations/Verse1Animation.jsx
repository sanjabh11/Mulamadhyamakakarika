import React, { useRef, useState, Suspense, useMemo } from 'react';
import { Canvas, useFrame } from '@react-three/fiber';
import { OrbitControls, useGLTF, Html, Instance, Instances, Decal, useTexture } from '@react-three/drei';
import * as THREE from 'three';
import styles from '../../styles/VerseAnimation.module.css';

// Load the GLB model generated by Blender
// Removed onScreenMeshReady prop and related useEffect
function SceneModel(props) {
    const { scene } = useGLTF('/blender_assets/verse_1_scene.glb');
    // You might need to adjust position, scale, rotation of the loaded scene
    return <primitive object={scene} {...props} scale={0.5} position={[0, -1, 0]} />;
}


// Particle simulation logic
const PARTICLE_COUNT = 500;
const MAX_HITS = 2000; // Limit number of decals for performance
const SOURCE_POS = new THREE.Vector3(0, 0, 2); // Matches Blender source position relative to model center (adjust Y if needed)
const SCREEN_Z = -2; // Matches Blender screen position relative to model center
const BARRIER_Z = 0; // Matches Blender barrier position
const BARRIER_THICKNESS = 0.1; // Approximate thickness for collision check
const SLIT_WIDTH = 0.2; // Must match Blender script
const SLIT_HEIGHT = 1.0; // Must match Blender script
const SLIT_SPACING = 0.6; // Must match Blender script
const SLIT_Y_CENTER = 0; // Assuming slits are centered vertically on the barrier

// Removed screenMesh prop
function QuantumSimulation({ isObserved }) {
  const meshRef = useRef(); // Ref for particle Instances
  const particles = useRef([]);
  const [hits, setHits] = useState([]); // Store hit positions { position: Vector3, id: number }
  let hitCounter = 0; // Simple counter for unique hit IDs

  // Texture for the hit decal - simple white circle
  const decalTexture = useMemo(() => {
    const size = 64;
    const canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    const context = canvas.getContext('2d');
    if (!context) return null; // Handle context creation failure
    context.fillStyle = 'white';
    context.beginPath();
    context.arc(size / 2, size / 2, size / 2, 0, Math.PI * 2);
    context.fill();
    return new THREE.CanvasTexture(canvas);
  }, []);


  // Initialize particles
  useState(() => {
    particles.current = []; // Clear previous particles if component re-renders unexpectedly
    for (let i = 0; i < PARTICLE_COUNT; i++) {
      particles.current.push({
        id: i,
        position: new THREE.Vector3(SOURCE_POS.x, SOURCE_POS.y, SOURCE_POS.z),
        velocity: new THREE.Vector3(
          (Math.random() - 0.5) * 0.5, // Spread slightly horizontally
          (Math.random() - 0.5) * 0.1, // Minimal vertical spread
          -(Math.random() * 0.03 + 0.02) // Move towards screen
        ),
        color: new THREE.Color(),
        active: true,
      });
    }
  });

  useFrame((state, delta) => {
    if (!meshRef.current) return;

    const tempObject = new THREE.Object3D(); // Reused for matrix updates
    const newHits = []; // Collect hits for this frame

    particles.current.forEach((p, i) => {
      if (!p.active) {
        // Hide inactive particles (set scale to 0)
        tempObject.position.set(0,0,0); // Move offscreen maybe?
        tempObject.scale.set(0, 0, 0);
        tempObject.updateMatrix();
        meshRef.current.setMatrixAt(i, tempObject.matrix);
        return;
      }

      // Update position
      const currentVelocity = p.velocity.clone(); // Use current velocity for this frame step
      p.position.addScaledVector(currentVelocity, delta * 60); // Adjust speed multiplier as needed

      const prevZ = p.position.z - currentVelocity.z * delta * 60; // Estimate previous Z position

      // --- Collision Detection & Behavior ---
      let hitBarrier = false;
      // Check if particle is about to cross the barrier plane
      if (prevZ > BARRIER_Z && p.position.z <= BARRIER_Z) {
        // Simple approximation for position at barrier
        const xAtBarrierApprox = p.position.x;
        const yAtBarrierApprox = p.position.y;

        const halfSlitSpacing = SLIT_SPACING / 2;
        const halfSlitWidth = SLIT_WIDTH / 2;
        const halfSlitHeight = SLIT_HEIGHT / 2;

        // Check if within Y bounds of slits
        const withinY = Math.abs(yAtBarrierApprox - SLIT_Y_CENTER) < halfSlitHeight;

        // Check if within X bounds of slit 1 or 2
        const withinX1 = Math.abs(xAtBarrierApprox - (-halfSlitSpacing)) < halfSlitWidth;
        const withinX2 = Math.abs(xAtBarrierApprox - (halfSlitSpacing)) < halfSlitWidth;

        if (withinY && (withinX1 || withinX2)) {
          // Passed through a slit - Modify velocity based on observation
          const speed = p.velocity.length(); // Preserve speed
          if (!isObserved) {
            // Wave behavior: Increase horizontal spread significantly
            p.velocity.x += (Math.random() - 0.5) * 0.15; // More spread
            p.velocity.y += (Math.random() - 0.5) * 0.02; // Slight vertical spread too
          } else {
            // Particle behavior: Minimal deviation
             p.velocity.x += (Math.random() - 0.5) * 0.002;
             p.velocity.y += (Math.random() - 0.5) * 0.001;
          }
          // Ensure Z velocity remains dominant towards screen
          p.velocity.z = -Math.abs(p.velocity.z);
          p.velocity.normalize().multiplyScalar(speed); // Re-apply speed
        } else {
          // Hit the barrier solid part
          hitBarrier = true;
        }
      }

      // --- Reset Logic & Hit Recording ---
      let particleHitScreen = false;
      // Check if particle crossed the screen plane in this frame
      if (p.position.z <= SCREEN_Z && prevZ > SCREEN_Z) {
          particleHitScreen = true;
          // Calculate hit position on the screen plane more accurately
          const t = (SCREEN_Z - prevZ) / (p.position.z - prevZ); // Interpolation factor
          const hitPos = new THREE.Vector3().lerpVectors(
              new THREE.Vector3(p.position.x - currentVelocity.x * delta * 60, p.position.y - currentVelocity.y * delta * 60, prevZ), // Better estimate of start point
              p.position, // End point
              t
          );
          hitPos.z = SCREEN_Z + 0.01; // Place decal slightly in front of screen to avoid z-fighting

          // Add hit to temporary array for this frame
          newHits.push({ position: hitPos, id: hitCounter++ });
      }

      // Reset if hit barrier OR went past screen after hitting it
      if (hitBarrier || particleHitScreen || p.position.z < SCREEN_Z - 1.0) { // Give some buffer past screen
         p.position.copy(SOURCE_POS);
         p.velocity.set(
            (Math.random() - 0.5) * 0.5,
            (Math.random() - 0.5) * 0.1,
           -(Math.random() * 0.03 + 0.02) // Initial velocity towards screen
         );
         p.active = true; // Ensure it's active again
         if (hitBarrier) p.active = false; // Deactivate particle if it hits barrier
      }

      // Update instance matrix
      tempObject.position.copy(p.position);
      tempObject.scale.set(1, 1, 1); // Ensure visible scale
      tempObject.updateMatrix();
      meshRef.current.setMatrixAt(i, tempObject.matrix);

      // Update instance color based on observation state
      p.color.set(isObserved ? 0xff0000 : 0x00ffff); // Red for observed, Cyan for unobserved
      meshRef.current.setColorAt(i, p.color);

      // TODO: Could adjust opacity based on state here if material supports it
    });

    // Update hits state after iterating through all particles
    if (newHits.length > 0) {
        setHits(prevHits => {
            const updatedHits = [...prevHits, ...newHits];
            if (updatedHits.length > MAX_HITS) {
                return updatedHits.slice(updatedHits.length - MAX_HITS); // Keep only the latest hits
            }
            return updatedHits;
        });
    }


    meshRef.current.instanceMatrix.needsUpdate = true;
    if (meshRef.current.instanceColor) {
      meshRef.current.instanceColor.needsUpdate = true;
    }
  });

  // Clear hits when observation state changes
  React.useEffect(() => {
      setHits([]);
      hitCounter = 0; // Reset counter as well
      // Force reset active state of particles
      particles.current.forEach(p => {
          p.position.copy(SOURCE_POS);
          p.velocity.set(
            (Math.random() - 0.5) * 0.5,
            (Math.random() - 0.5) * 0.1,
           -(Math.random() * 0.03 + 0.02)
         );
         p.active = true;
      });
  }, [isObserved]);

  return (
    // Use a group to contain instances and decals
    <group>
        <Instances ref={meshRef} limit={PARTICLE_COUNT} range={PARTICLE_COUNT}>
          <sphereGeometry args={[0.02, 8, 8]} />
          {/* Use vertexColors and allow transparency for wave state? */}
          <meshStandardMaterial roughness={0.5} metalness={0.5} vertexColors />
        </Instances>

        {/* Render simple spheres for hits */}
        {hits.map(hit => (
            <mesh key={hit.id} position={hit.position} scale={0.03}> {/* Smaller scale for hit marks */}
                <sphereGeometry args={[1, 8, 8]} />
                <meshBasicMaterial
                    color={isObserved ? 0xff0000 : 0x00ffff}
                    toneMapped={false}
                    depthTest={false} // Render on top
                 />
            </mesh>
        ))}
    </group>
  );
}


// Main component for Verse 1 animation
export default function Verse1Animation() {
  const [isObserved, setIsObserved] = useState(false); // State to toggle between wave/particle
  // Removed screen mesh state and callback
  const [isPanelVisible, setIsPanelVisible] = useState(true); // State for panel visibility

  const verseText = "No thing anywhere is ever born from itself, from something else, from both or without a cause.";
  const explanation = "The double-slit experiment shows that particles like electrons behave as waves (spreading out and interfering) when unobserved, but as particles (hitting specific spots) when observed. This mirrors the Madhyamaka concept that phenomena lack inherent, fixed existence (svabhava) and their nature depends on conditions, including observation.";

  return (
    <div className={styles.verseContainer}>
      <Canvas camera={{ position: [0, 1, 8], fov: 50 }}>
        <ambientLight intensity={0.5} />
        <pointLight position={[5, 10, 10]} intensity={1} />
        <Suspense fallback={<Html center>Loading 3D Scene...</Html>}>
          {/* Removed callback prop */}
          <SceneModel />
          {/* Removed screenMesh prop */}
          <QuantumSimulation isObserved={isObserved} />
        </Suspense>
        <OrbitControls enableZoom={true} enablePan={true} />
      </Canvas>

      {/* --- UI Elements --- */}
      {/* Button to show panel if hidden */}
      {!isPanelVisible && (
        <button onClick={() => setIsPanelVisible(true)} className={styles.showButton}>
          Show Info
        </button>
      )}

      {/* Conditionally render panel based on state */}
      <div className={`${styles.controlsPanel} ${isPanelVisible ? styles.visible : styles.hidden}`}>
         {/* Button to hide the panel itself */}
         <button onClick={() => setIsPanelVisible(false)} className={styles.hideButton}>
           Hide Panel [X]
         </button>

        <h3>Verse 1: Rejection of Inherent Existence</h3>
        <p><em>{verseText}</em></p>
        <button onClick={() => setIsObserved(!isObserved)}>
          Toggle Observation ({isObserved ? 'Observed - Particle' : 'Unobserved - Wave'})
        </button>

        <div className={styles.explanationBox}>
          <h4>Explanation</h4>
          <p>{explanation}</p>
          <p><strong>Quantum Parallel:</strong> Copenhagen Interpretation</p>
          <p><strong>Real-Life Example:</strong> A shadow - its existence depends on the object and light.</p>
        </div>
      </div>
    </div>
  );
}

// Preload the model
useGLTF.preload('/blender_assets/verse_1_scene.glb');
